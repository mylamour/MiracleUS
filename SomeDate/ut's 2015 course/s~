return kickBall(KICK_FORWARD, VecPosition(HALF_FIELD_X, 0, 0));



 static SkillType lastKickSelected = SKILL_NONE;
    static double lastKickSelectedTime = -1;
    double angleThreshold;
    double lateralThreshold;
    SkillType tempSkill;
    VecPosition target;

    SIM::Point2D ballVel = worldModel->getWorldObject(WO_BALL)->absVel;

    // If we're within 1 meter of the ball and not dribbling, we need to select a kick and position ourselves
    // Dribbling is handled later
    if (me.getDistanceTo(ball) <= 1 && KICK_DRIBBLE != kickType) {
        // Figure out which kick to use (left or right foot)
        SkillType kick;
        double ball_dist;
        double ball_angle;
        double target_dist;
        double target_angle;
        getTargetDistanceAndAngle(ball, ball_dist, ball_angle);
        getTargetDistanceAndAngle(kickTarget, target_dist, target_angle);
        SkillType kick_array[2];
        getSkillsForKickType(kickType, kick_array);
        const int NUM_KICKS = sizeof(kick_array)/sizeof(SkillType);
        double lowestKickCost = 99999999;
        SkillType kickSkill = kick_array[0];
        for (int k = 0; k < NUM_KICKS; k++) {
            SkillType kick = kick_array[k];
            double kickCost = computeKickCost(kickTarget, kick);
            if (kickCost < lowestKickCost) {
                lowestKickCost = kickCost;
                kickSkill = kick;
            }
        }

        static double timeLastSetTarget = -100;
        static VecPosition currentTarget = VecPosition(0,0,0);

        // May only change target every five seconds or if kickType changes
        // When changing target reset everything
        VecPosition targetToKickAt;
        if (worldModel->getTime()-timeLastSetTarget > 5  || currentKickType != kickType || currentKick == SKILL_NONE) {
            timeLastSetTarget = worldModel->getTime();
            currentTarget = kickTarget;
            lastKickSelected = kickSkill;
            lastKickSelectedTime = worldModel->getTime();
            currentKick = kickSkill;
            currentKickType = kickType;

        }


        if (lastKickSelected != kickSkill) {
            lastKickSelected = kickSkill;
            lastKickSelectedTime = worldModel->getTime();
        }

        // Kick skill hysteresis requires us to hold a kick skill for a certain amount of time before switching (but don't switch between kick types)
        if (worldModel->getTime() - lastKickSelectedTime > .5 && currentKickType == kickType) {
            currentKick = lastKickSelected;
        }

        return kickBallAtTargetSimplePositioning(currentTarget, currentKick, currentKickType);
    } else {
        // Here is how we dribble

        currentKickType = KICK_DRIBBLE;
        angleThreshold = 10;

        VecPosition localBall = worldModel->g2l(ball);
        localBall.setZ(0);
        SIM::AngDeg localBallAngle = atan2Deg(localBall.getY(), localBall.getX());
        VecPosition me2Ball = ball - me;

        SIM::AngDeg angleError = abs(VecPosition(0, 0, 0).getAngleBetweenPoints(kickDirection, me2Ball));
        SIM::AngDeg turnAngle = localBallAngle;

        if (angleError < angleThreshold) {
            // Dribble
            return goToTargetRelative(localBall, turnAngle);
        }

        VecPosition ballTarget = ball;

        target = ballTarget - (VecPosition(kickDirection)  * atof(namedParams.find("drib_target")->second.c_str()));
        target.setZ(0);

        VecPosition originalTarget = target;
        target = navigateAroundBall(target, .5 /*PROXIMITY_TRESH*/,atof(namedParams.find("drib_coll_thresh")->second.c_str()));
        target = collisionAvoidance(true /*Avoid teamate*/, false /*Avoid opponent*/, false /*Avoid ball*/, .5, .5, target,
                                    false /*fKeepDistance*/);
        target = collisionAvoidance(false /*Avoid teamate*/, false /*Avoid opponent*/, true /*Avoid ball*/, .5 /*PROXIMITY_TRESH*/,
                                    atof(namedParams.find("drib_coll_thresh")->second.c_str()), target);
        VecPosition localTarget = worldModel->g2l(target);
        SIM::AngDeg localTargetAngle = atan2Deg(localTarget.getY(), localTarget.getX());
        //cout << "CIRCLE\t" << worldModel->getGameTime() << "\n";
        return goToTargetRelative(localTarget, turnAngle, 1.0, false /*fAllowOver180Turn*/);
    }
